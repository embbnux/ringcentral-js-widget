{"version":3,"sources":["lib/proxy/getProxyServer.js"],"names":["getProxyServer","createTarget","transport","options","actionTypes","baseActionTypes","_target","_getState","state","target","subModule","Object","prototype","hasOwnProperty","RcModule","configurable","enumerable","get","_transport","ensureExist","_reducer","moduleReducer","reducer","prefix","on","events","request","requestId","payload","type","functionPath","args","actionNumber","execute","sync","split","slice","pathTokens","fnName","pop","forEach","token","result","response","error","Error"],"mappings":"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","file":"getProxyServer.js","sourcesContent":["import RcModule from '../RcModule';\nimport baseActionTypes from './baseActionTypes';\nimport getProxyServerReducer from './getProxyServerReducer';\nimport ensureExist from '../ensureExist';\n\nexport default function getProxyServer(createTarget) {\n  return class extends RcModule {\n    constructor({ transport, ...options }) {\n      super({\n        ...options,\n        actionTypes: baseActionTypes,\n      });\n      this._target = createTarget({\n        ...options,\n      });\n      this._target._getState = () => this.state.target;\n\n      for (const subModule in this._target) {\n        if (\n          this._target::Object.prototype.hasOwnProperty(subModule) &&\n            this._target[subModule] instanceof RcModule\n        ) {\n          Object.defineProperty(this, subModule, {\n            configurable: false,\n            enumerable: true,\n            get() {\n              return this._target[subModule];\n            },\n          });\n        }\n      }\n\n      this._transport = this::ensureExist(transport, 'transport');\n      this._reducer = getProxyServerReducer({\n        moduleReducer: this._target.reducer,\n        transport,\n        prefix: this.prefix,\n      });\n\n      transport.on(\n        transport.events.request,\n        async ({\n          requestId,\n          payload: {\n            type,\n            functionPath,\n            args,\n            actionNumber\n          },\n        }) => {\n          switch (type) {\n            case this.actionTypes.execute: {\n              const [...pathTokens] = functionPath.split('.').slice(1);\n              const fnName = pathTokens.pop();\n              let target = this._target;\n              pathTokens.forEach((token) => {\n                target = target[token];\n              });\n              try {\n                const result = await target[fnName](...args);\n                transport.response({\n                  requestId,\n                  result,\n                });\n              } catch (error) {\n                transport.response({\n                  requestId,\n                  error,\n                });\n              }\n            }\n              break;\n            case this.actionTypes.sync: {\n              if (actionNumber !== this.state.actionNumber) {\n                transport.response({\n                  requestId,\n                  result: this.state,\n                });\n              } else {\n                transport.response({\n                  requestId,\n                  error: new Error('State is already up to date.'),\n                });\n              }\n              break;\n            }\n            default:\n              transport.response({\n                requestId,\n                error: new Error(`Invalid request type '${type}'.`)\n              });\n              break;\n          }\n        },\n      );\n    }\n  };\n}\n"]}