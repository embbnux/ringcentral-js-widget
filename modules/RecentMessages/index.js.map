{"version":3,"sources":["modules/RecentMessages/index.js"],"names":["RecentMessages","deps","client","messageStore","options","actionTypes","_client","ensureExist","_messageStore","_reducer","addSelector","messages","reduce","unreadCounts","contactId","acc","cur","readStatus","_prevMessageStoreTimestamp","store","subscribe","_onStateChange","pending","ready","dispatch","type","initSuccess","resetSuccess","length","updatedTimestamp","contacts","key","getMessages","currentContact","sessionId","indexOf","split","fromLocale","forceUpdate","fromLocal","id","initLoad","_getRecentMessages","textConversations","loadSuccess","contact","loadReset","conversations","daySpan","dateFrom","recentMessages","_getLocalRecentMessages","dateTo","creationTime","undefined","_fetchRemoteRecentMessages","toISOString","concat","console","error","_dedup","slice","phoneNumbers","matches","i","conversation","messageList","conversationStore","conversationId","find","_filterPhoneNumber","Date","sort","sortByDate","message","phoneNumber","from","to","extensionNumber","params","messageType","perPage","recentMessagesPromise","promise","_fetchMessageList","then","_flattenToMessageRecords","_markAsRemoteMessage","_sortMessages","account","extension","list","allMessages","records","a","b","map","fromRemote","hash","state","_selectors","unreadMessageCounts","messageStatus","loaded","status","RcModule","proxify"],"mappings":"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","file":"index.js","sourcesContent":["import proxify from '../../lib/proxy/proxify';\nimport ensureExist from '../../lib/ensureExist';\nimport RcModule from '../../lib/RcModule';\nimport { Module } from '../../lib/di';\nimport actionTypes from './actionTypes';\nimport messageStatus from './messageStatus';\nimport getRecentMessagesReducer from './getRecentMessagesReducer';\nimport getDateFrom from '../../lib/getDateFrom';\nimport concurrentExecute from '../../lib/concurrentExecute';\nimport { sortByDate } from '../../lib/messageHelper';\n\n/**\n * @class\n * @description Retrieve all recent messages related to a specified contact.\n */\n@Module({\n  deps: ['Client', 'MessageStore']\n})\nexport default class RecentMessages extends RcModule {\n  /**\n   * @constructor\n   * @param {Object} params - params object\n   * @param {MessageStore} params.messageStore - messageStore module instance\n   * @param {Client} params.client - client module instance\n   */\n  constructor({\n    client,\n    messageStore,\n    ...options\n  }) {\n    super({\n      actionTypes,\n      ...options\n    });\n    this._client = this:: ensureExist(client, 'client');\n    this._messageStore = this:: ensureExist(messageStore, 'messageStore');\n    this._reducer = getRecentMessagesReducer(this.actionTypes);\n\n    this.addSelector(\n      'unreadMessageCounts',\n      () => this.messages,\n      messages => (\n        Object.keys(messages).reduce((unreadCounts, contactId) => {\n          unreadCounts[contactId] = messages[contactId]\n            .reduce((acc, cur) => acc + (cur.readStatus !== 'Read' ? 1 : 0), 0);\n          return unreadCounts;\n        }, {})\n      )\n    );\n\n    this._prevMessageStoreTimestamp = null;\n  }\n\n  initialize() {\n    this.store.subscribe(() => this._onStateChange());\n  }\n\n  _onStateChange() {\n    if (\n      this.pending &&\n      this._messageStore.ready\n    ) {\n      this.store.dispatch({\n        type: this.actionTypes.initSuccess,\n      });\n    } else if (\n      this.ready &&\n      !this._messageStore.ready\n    ) {\n      this.store.dispatch({\n        type: this.actionTypes.resetSuccess\n      });\n    } else if (Object.keys(this.messages).length > 0) {\n      // Listen to messageStore state changes\n      if (this._messageStore.updatedTimestamp !== this._prevMessageStoreTimestamp) {\n        this._prevMessageStoreTimestamp = this._messageStore.updatedTimestamp;\n        // for (const contact of Object.values(this.contacts)) {\n        //   this.getMessages(contact, false, true);\n        // }\n        for (const key of Object.keys(this.contacts)) {\n          this.getMessages({\n            currentContact: this.contacts[key],\n            sessionId: key.indexOf('-') > -1 ? key.split('-')[1] : null,\n            fromLocale: false,\n            forceUpdate: true\n          });\n        }\n      }\n    }\n  }\n\n  get contacts() {\n    return this.state.contacts;\n  }\n\n  get messages() {\n    return this.state.messages;\n  }\n\n  get unreadMessageCounts() {\n    return this._selectors.unreadMessageCounts();\n  }\n\n  get isMessagesLoaded() {\n    return this.state.messageStatus === messageStatus.loaded;\n  }\n\n  @proxify\n  async getMessages({\n    currentContact, sessionId = null, fromLocal = false, forceUpdate = false\n  }) {\n    // No need to calculate recent messages of the same contact repeatly\n    if (!currentContact) {\n      return;\n    }\n    const contactId = currentContact.id;\n    if (\n      !forceUpdate &&\n      !!this.messages[sessionId ? `${contactId}-${sessionId}` : contactId]\n    ) {\n      return;\n    }\n    this._prevMessageStoreTimestamp = this._messageStore.updatedTimestamp;\n    this.store.dispatch({\n      type: this.actionTypes.initLoad\n    });\n    const messages = await this._getRecentMessages(\n      currentContact,\n      this._messageStore.textConversations,\n      fromLocal\n    );\n    this.store.dispatch({\n      type: this.actionTypes.loadSuccess,\n      messages,\n      contact: currentContact,\n      sessionId,\n    });\n  }\n\n  cleanUpMessages({ contact, sessionId = null }) {\n    this.store.dispatch({\n      type: this.actionTypes.loadReset,\n      contact,\n      sessionId\n    });\n  }\n\n  get status() {\n    return this.state.status;\n  }\n\n  /**\n   * Searching for recent messages of specific contact.\n   * @param {Object} currentContact - Current contact\n   * @param {Array} messages - Messages in messageStore\n   * @param {Boolean} fromLocal - Only get recent messages locally\n   * @param {Number} daySpan - Find messages within certain days\n   * @param {Number} length - Maximum length of recent messages\n   * @return {Array}\n   * @private\n   */\n  async _getRecentMessages(currentContact, conversations = [], fromLocal, daySpan = 60, length = 5) {\n    const dateFrom = getDateFrom(daySpan);\n    let recentMessages = this._getLocalRecentMessages(\n      currentContact,\n      conversations,\n      dateFrom,\n      length\n    );\n\n    // If we could not find enough recent messages,\n    // we need to search for messages on server.\n    if (!fromLocal && recentMessages.length < length) {\n      const dateTo = recentMessages.length > 0\n        ? recentMessages[recentMessages.length - 1].creationTime\n        : undefined;\n\n      try {\n        // This will always be sorted\n        recentMessages = recentMessages.concat(\n          await this._fetchRemoteRecentMessages(\n            currentContact,\n            dateFrom.toISOString(),\n            dateTo.toISOString(),\n            length\n          )\n        );\n      } catch (error) {\n        console.error(error);\n      }\n    }\n\n    recentMessages = this._dedup(recentMessages);\n    return recentMessages.length > length\n      ? recentMessages.slice(0, length)\n      : recentMessages;\n  }\n\n  /**\n   * Get recent messages from messageStore.\n   * @param {Object} currentContact\n   * @param {Array} messages\n   * @param {Date} dateFrom\n   * @param {Number} length\n   */\n  _getLocalRecentMessages({ phoneNumbers }, conversations, dateFrom, length) {\n    // Get all messages related to this contact\n    let recentMessages = [];\n    let matches;\n    for (let i = conversations.length - 1; i >= 0; i -= 1) {\n      const conversation = conversations[i];\n      const messageList = this._messageStore.conversationStore[conversation.conversationId] || [];\n      matches = phoneNumbers.find(this._filterPhoneNumber(conversation));\n      // Check if message is within certain days\n      if (!!matches && new Date(conversation.creationTime) > dateFrom) {\n        recentMessages = recentMessages.concat(messageList);\n      }\n      if (recentMessages.length >= length) break;\n    }\n    return recentMessages.sort(sortByDate).slice(0, length);\n  }\n\n  _filterPhoneNumber(message) {\n    return ({ phoneNumber }) => (\n      phoneNumber === message.from.phoneNumber ||\n      !!message.to.find(to => to.phoneNumber === phoneNumber) ||\n      phoneNumber === message.from.extensionNumber ||\n      !!message.to.find(to => to.extensionNumber === phoneNumber)\n    );\n  }\n\n  /**\n   * Fetch recent messages from server by given current contact.\n   * @param {Object} currentContact\n   * @param {String} dateFrom\n   * @param {String} dateTo\n   * @param {Number} length The number of messages\n   * @return {Array}\n   */\n  _fetchRemoteRecentMessages(\n    { phoneNumbers },\n    dateFrom,\n    dateTo = (new Date()).toISOString(),\n    length\n  ) {\n    const params = {\n      dateTo,\n      dateFrom,\n      messageType: ['SMS', 'Text', 'Pager'],\n      perPage: length\n    };\n    const recentMessagesPromise = phoneNumbers.reduce((acc, { phoneNumber }) => {\n      if (phoneNumber) {\n        const promise = this._fetchMessageList(\n          Object.assign({}, params, {\n            phoneNumber\n          })\n        );\n        return acc.concat(promise);\n      }\n      return acc;\n    }, []);\n\n    // TODO: Because we need to navigate to the message page,\n    // So we may need to push new messages to messageStore\n    return concurrentExecute(recentMessagesPromise, 5, 500)\n      .then(this._flattenToMessageRecords)\n      .then(this._markAsRemoteMessage)\n      .then(messages => this._sortMessages(messages));\n  }\n\n  _fetchMessageList(params) {\n    return () => this._client.account().extension().messageStore().list(params);\n  }\n\n  _countUnreadMessages(messages) {\n    return messages.reduce((acc, cur) => acc + (cur.readStatus !== 'Read' ? 1 : 0), 0);\n  }\n\n  _flattenToMessageRecords(allMessages) {\n    return allMessages.reduce((acc, { records }) => acc.concat(records), []);\n  }\n\n  _sortMessages(recentMessages) {\n    // Sort by time in descending order\n    return recentMessages.sort((a, b) =>\n      new Date(b.creationTime) - new Date(a.creationTime)\n    );\n  }\n\n  _markAsRemoteMessage(messages) {\n    return messages.map((message) => {\n      message.fromRemote = true;\n      return message;\n    });\n  }\n\n  _dedup(messages) {\n    const hash = {};\n    return messages.reduce((acc, cur) => {\n      if (hash[cur.id]) return acc;\n      hash[cur.id] = true;\n      return acc.concat(cur);\n    }, []);\n  }\n}\n"]}